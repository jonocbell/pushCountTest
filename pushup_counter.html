<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Push-Up Counter">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#667eea">
    <meta name="msapplication-TileColor" content="#667eea">
    <meta name="description" content="AI-powered push-up counter using Google's MoveNet model">
    
    <!-- PWA Manifest -->
    <link rel="manifest" id="manifest-placeholder">
    
    <!-- Favicon and Apple Touch Icons -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E🏋️‍♂️%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E🏋️‍♂️%3C/text%3E%3C/svg%3E">
    
    <title>AI Push-Up Counter - MoveNet</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@latest"></script>
    <style>
        /* Mobile-first responsive design */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            min-height: 100dvh; /* Dynamic viewport height for mobile */
            overflow-x: hidden;
            position: relative;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            min-height: 100dvh;
        }
        
        h1 {
            font-size: clamp(1.2rem, 6vw, 2rem);
            margin: 10px 0 15px 0;
            text-align: center;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            line-height: 1.2;
        }
        
        /* Video container - optimized for mobile screens */
        .video-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            margin-bottom: 15px;
            width: 100%;
            max-height: 50vh; /* Limit height to save screen space */
            background: #000;
            flex-shrink: 0;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transform: scaleX(-1); /* Mirror front camera by default */
            max-height: 50vh;
        }
        
        #video.rear-camera {
            transform: scaleX(1); /* Don't mirror rear camera */
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Mobile-optimized stats layout */
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin: 15px 0;
            flex-shrink: 0;
        }
        
        .stat-card {
            background: rgba(255,255,255,0.15);
            padding: 12px 8px;
            border-radius: 12px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            min-height: 65px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .stat-number {
            font-size: clamp(1.2rem, 7vw, 2rem);
            font-weight: 800;
            display: block;
            color: #ffeb3b;
            line-height: 1;
            margin-bottom: 2px;
        }
        
        .stat-label {
            font-size: clamp(0.7rem, 3vw, 0.9rem);
            opacity: 0.9;
            font-weight: 500;
            line-height: 1;
        }
        
        /* Mobile-first button design */
        .controls {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-shrink: 0;
        }
        
        .button-row {
            display: flex;
            gap: 8px;
            width: 100%;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 16px 20px;
            font-size: clamp(0.9rem, 4vw, 1.1rem);
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 52px;
            touch-action: manipulation;
            position: relative;
            overflow: hidden;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1.2;
        }
        
        button:active {
            transform: scale(0.98);
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            opacity: 0.6;
            transform: none;
        }
        
        button.secondary {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        button.secondary:active {
            background: rgba(255,255,255,0.25);
        }
        
        /* Mobile-optimized position indicator */
        .position-indicator {
            font-size: clamp(1rem, 5vw, 1.3rem);
            margin: 12px 0;
            padding: 12px 16px;
            border-radius: 12px;
            font-weight: 700;
            text-align: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        
        .position-up {
            background: rgba(76, 175, 80, 0.4);
            color: #4CAF50;
            border: 2px solid #4CAF50;
        }
        
        .position-down {
            background: rgba(255, 152, 0, 0.4);
            color: #FF9800;
            border: 2px solid #FF9800;
        }
        
        .position-middle {
            background: rgba(33, 150, 243, 0.4);
            color: #2196F3;
            border: 2px solid #2196F3;
        }
        
        .position-neutral {
            background: rgba(158, 158, 158, 0.4);
            color: #9E9E9E;
            border: 2px solid #9E9E9E;
        }
        
        /* Status message - mobile optimized */
        .status {
            font-size: clamp(0.85rem, 3.5vw, 1rem);
            margin: 12px 0;
            padding: 12px 16px;
            border-radius: 12px;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
            line-height: 1.4;
            flex-shrink: 0;
        }
        
        /* Instructions - collapsible on mobile */
        .instructions {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            margin: 15px 0 0 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .instructions-header {
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .instructions-header h3 {
            font-size: clamp(0.9rem, 4vw, 1.1rem);
            margin: 0;
            font-weight: 600;
        }
        
        .instructions-toggle {
            font-size: 1.2rem;
            transition: transform 0.2s ease;
        }
        
        .instructions-content {
            padding: 12px 16px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .instructions-content.expanded {
            max-height: 300px;
        }
        
        .instructions ul {
            margin: 0;
            padding-left: 16px;
        }
        
        .instructions li {
            font-size: clamp(0.75rem, 3vw, 0.85rem);
            margin-bottom: 6px;
            line-height: 1.3;
        }
        
        /* Landscape orientation optimizations */
        @media screen and (orientation: landscape) and (max-height: 600px) {
            .container {
                flex-direction: row;
                align-items: flex-start;
                gap: 10px;
            }
            
            .video-container {
                flex: 1;
                max-height: 70vh;
                margin-bottom: 0;
            }
            
            .controls-panel {
                flex: 0 0 300px;
                display: flex;
                flex-direction: column;
                height: 100vh;
                overflow-y: auto;
                padding-left: 10px;
            }
            
            h1 {
                font-size: 1.2rem;
                margin: 5px 0 10px 0;
            }
            
            .stats {
                margin: 10px 0;
                gap: 6px;
            }
            
            .stat-card {
                padding: 8px 6px;
                min-height: 50px;
            }
            
            .instructions {
                margin: 10px 0 0 0;
            }
        }
        
        /* Very small screens */
        @media (max-width: 360px) {
            body {
                padding: 4px;
            }
            
            h1 {
                margin: 8px 0 12px 0;
            }
            
            .video-container {
                margin-bottom: 12px;
                border-radius: 8px;
            }
            
            .stats {
                gap: 6px;
                margin: 12px 0;
            }
            
            .stat-card {
                padding: 10px 6px;
                border-radius: 8px;
                min-height: 60px;
            }
            
            .controls {
                gap: 10px;
                margin: 12px 0;
            }
            
            button {
                min-height: 48px;
                padding: 14px 16px;
                border-radius: 8px;
            }
            
            .position-indicator {
                margin: 10px 0;
                padding: 10px 12px;
                border-radius: 8px;
            }
            
            .status {
                margin: 10px 0;
                padding: 10px 12px;
                border-radius: 8px;
            }
        }
        
        /* Performance optimizations for mobile */
        .video-container,
        .stat-card,
        .position-indicator,
        .status,
        .instructions {
            will-change: auto;
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        /* PWA and fullscreen support */
        @media (display-mode: standalone) {
            body {
                padding-top: max(8px, env(safe-area-inset-top));
                padding-bottom: max(8px, env(safe-area-inset-bottom));
                padding-left: max(8px, env(safe-area-inset-left));
                padding-right: max(8px, env(safe-area-inset-right));
            }
        }
        
        /* High DPI screens */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            button, .stat-card, .position-indicator, .status {
                border: 1px solid rgba(255,255,255,0.2);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🏋️‍♂️ Push-Up Counter</h1>
        
        <div class="video-container">
            <video id="video" autoplay muted playsinline webkit-playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="controls-panel">
            <div class="controls">
                <button id="startBtn">Start Camera</button>
                <div class="button-row">
                    <button id="switchCameraBtn" class="secondary" style="display: none;">🔄 Switch</button>
                    <button id="resetBtn" class="secondary">🔄 Reset</button>
                    <button id="debugBtn" class="secondary" style="display: none;">🔍 Debug</button>
                </div>
            </div>
            
            <div class="stats">
                <div class="stat-card">
                    <span class="stat-number" id="pushupCount">0</span>
                    <span class="stat-label">Push-ups</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number" id="currentPosition">--</span>
                    <span class="stat-label">Position</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number" id="confidence">--</span>
                    <span class="stat-label">Confidence</span>
                </div>
            </div>
            
            <div class="position-indicator" id="positionIndicator">
                Ready to start
            </div>
            
            <div class="status" id="status">
                Click "Start Camera" to begin with Google's MoveNet AI
            </div>
            
            <div class="instructions">
                <div class="instructions-header" onclick="toggleInstructions()">
                    <h3>📋 Instructions</h3>
                    <span class="instructions-toggle" id="instructionsToggle">▼</span>
                </div>
                <div class="instructions-content" id="instructionsContent">
                    <ul>
                        <li><strong>Advanced AI:</strong> Now powered by Google's MoveNet model - ultra-fast and accurate!</li>
                        <li><strong>Auto-detection:</strong> No calibration needed - just start exercising!</li>
                        <li><strong>Position yourself:</strong> Make sure your upper body and arms are visible in the camera</li>
                        <li><strong>Visual tracking:</strong> Colored keypoints and skeleton show real-time body tracking</li>
                        <li><strong>Smart counting:</strong> Automatically counts complete push-ups with proper form</li>
                        <li><strong>Camera options:</strong> Starts with front camera to see your count, switch to rear if preferred</li>
                        <li><strong>Real-time:</strong> Optimized for mobile with 30+ FPS performance</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PushUpCounter {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.countDisplay = document.getElementById('pushupCount');
                this.statusDisplay = document.getElementById('status');
                this.debugDisplay = document.getElementById('debugBtn');
                this.positionDisplay = document.getElementById('currentPosition');
                this.positionIndicator = document.getElementById('positionIndicator');
                this.confidenceDisplay = document.getElementById('confidence');
                
                this.model = null;
                this.isRunning = false;
                this.pushUpCount = 0;
                this.position = 'unknown';
                this.lastPosition = 'unknown';
                this.minConfidence = 0.3;
                this.performanceMode = false;
                this.facingMode = 'user'; // Start with front camera
                this.inferenceTime = 0; // Track inference performance
                this.currentStream = null;
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.updateDisplay();
            }
            
            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startCamera();
                });
                
                document.getElementById('switchCameraBtn').addEventListener('click', () => {
                    this.switchCamera();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetCounter();
                });
                
                document.getElementById('debugBtn').addEventListener('click', () => {
                    this.showDebugInfo();
                });
            }
            
            async startCamera() {
                try {
                    this.updateStatus('Loading camera...');
                    
                    // Check if running on HTTPS or localhost
                    const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                    
                    if (!isSecure) {
                        this.updateStatus('⚠️ Camera requires HTTPS. Please use: 1) GitHub Pages 2) CodePen 3) Netlify Drop');
                        return;
                    }
                    
                    // Check for getUserMedia support
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        // Fallback for older browsers
                        navigator.getUserMedia = navigator.getUserMedia || 
                                               navigator.webkitGetUserMedia || 
                                               navigator.mozGetUserMedia || 
                                               navigator.msGetUserMedia;
                        
                        if (!navigator.getUserMedia) {
                            this.updateStatus('❌ Camera not supported by your browser. Try Chrome or Safari.');
                            return;
                        }
                        
                        // Use legacy getUserMedia
                        const constraints = {
                            video: { 
                                width: { ideal: 640, max: 1280 },
                                height: { ideal: 480, max: 720 },
                                facingMode: this.facingMode
                            }
                        };
                        
                        navigator.getUserMedia(constraints, (stream) => {
                            this.currentStream = stream;
                            this.video.srcObject = stream;
                            this.video.addEventListener('loadeddata', () => {
                                this.setupCanvas();
                                this.loadModel();
                                this.updateVideoMirror();
                            });
                            document.getElementById('startBtn').disabled = true;
                            document.getElementById('switchCameraBtn').style.display = 'block';
                            document.getElementById('debugBtn').style.display = 'block';
                        }, (error) => {
                            console.error('Legacy getUserMedia error:', error);
                            this.updateStatus('Error: ' + error.message);
                        });
                        return;
                    }
                    
                    // Use current facing mode (starts with front camera so user can see the count)
                    let constraints = {
                        video: { 
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            facingMode: this.facingMode
                        }
                    };
                    
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia(constraints);
                        this.currentStream = stream;
                        this.video.srcObject = stream;
                    } catch (error) {
                        // Fallback to opposite camera
                        console.log(`${this.facingMode} camera not available, trying opposite camera`);
                        constraints.video.facingMode = this.facingMode === 'user' ? 'environment' : 'user';
                        const stream = await navigator.mediaDevices.getUserMedia(constraints);
                        this.currentStream = stream;
                        this.facingMode = constraints.video.facingMode;
                        this.video.srcObject = stream;
                    }
                    
                    this.video.addEventListener('loadeddata', () => {
                        this.setupCanvas();
                        this.loadModel();
                        this.updateVideoMirror();
                    });
                    
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('switchCameraBtn').style.display = 'block';
                    document.getElementById('debugBtn').style.display = 'block';
                    
                } catch (error) {
                    console.error('Error accessing camera:', error);
                    let errorMessage = 'Error accessing camera: ';
                    
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Camera permission denied. Please allow camera access.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += 'No camera found on this device.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'Camera not supported by your browser.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus(errorMessage);
                }
            }
            
            async switchCamera() {
                try {
                    // Stop current stream
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                    }
                    
                    // Switch facing mode
                    this.facingMode = this.facingMode === 'user' ? 'environment' : 'user';
                    
                    // Start new stream
                    this.updateStatus('Switching camera...');
                    
                    const constraints = {
                        video: { 
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            facingMode: this.facingMode
                        }
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.currentStream = stream;
                    this.video.srcObject = stream;
                    
                    // Reset detection when switching cameras
                    this.position = 'unknown';
                    this.lastPosition = 'unknown';
                    
                    this.video.addEventListener('loadeddata', () => {
                        this.setupCanvas();
                        this.updateVideoMirror();
                        this.updateStatus('Camera switched! Ready to detect push-ups.');
                    });
                    
                } catch (error) {
                    console.error('Error switching camera:', error);
                    this.updateStatus('Error switching camera: ' + error.message);
                }
            }
            
            setupCanvas() {
                // Set canvas size to match video dimensions with mobile optimization
                const videoRect = this.video.getBoundingClientRect();
                
                // Use device pixel ratio for crisp rendering on high-DPI screens
                const devicePixelRatio = window.devicePixelRatio || 1;
                
                // Set display size (CSS pixels)
                this.canvas.style.width = videoRect.width + 'px';
                this.canvas.style.height = videoRect.height + 'px';
                
                // Set actual size in memory (scaled by device pixel ratio for clarity)
                // But limit to reasonable size for mobile performance
                const maxSize = 640; // Maximum dimension for mobile performance
                let canvasWidth = videoRect.width * devicePixelRatio;
                let canvasHeight = videoRect.height * devicePixelRatio;
                
                // Scale down if too large for mobile
                if (canvasWidth > maxSize || canvasHeight > maxSize) {
                    const scale = Math.min(maxSize / canvasWidth, maxSize / canvasHeight);
                    canvasWidth *= scale;
                    canvasHeight *= scale;
                }
                
                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;
                
                // Scale the drawing context back to match the display size
                this.ctx.scale(canvasWidth / videoRect.width, canvasHeight / videoRect.height);
                
                console.log(`Canvas setup: display ${videoRect.width}x${videoRect.height}, memory ${canvasWidth}x${canvasHeight}, DPR: ${devicePixelRatio}`);
            }
            
            updateVideoMirror() {
                // Mirror front camera, don't mirror rear camera
                if (this.facingMode === 'user') {
                    this.video.classList.remove('rear-camera');
                } else {
                    this.video.classList.add('rear-camera');
                }
            }
            
            async loadModel() {
                try {
                    this.updateStatus('Loading MoveNet model...');
                    console.log('Starting MoveNet model load...');
                    
                    // Load the official TensorFlow Hub MoveNet Lightning model using correct method
                    const modelUrl = 'https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4';
                    
                    console.log('Loading model from:', modelUrl);
                    // Use tf.loadGraphModel for TensorFlow Hub models
                    this.model = await tf.loadGraphModel(modelUrl, {fromTFHub: true});
                    
                    console.log('MoveNet model loaded successfully:', this.model);
                    
                    // Warm up the model with a dummy prediction for better performance
                    await this.warmUpModel();
                    
                    this.updateStatus('🚀 Ready! Position yourself and start your push-ups!');
                    this.startDetection();
                    
                } catch (error) {
                    console.error('Error loading MoveNet model:', error);
                    this.updateStatus('Error loading model: ' + error.message + ' - Trying alternatives...');
                    
                    // Try alternative model URLs
                    this.tryAlternativeModel();
                }
            }
            
            async tryAlternativeModel() {
                // Multiple fallback models in order of preference
                const modelUrls = [
                    'https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4',
                    'https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/3',
                    'https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/3'
                ];
                
                for (let i = 0; i < modelUrls.length; i++) {
                    try {
                        this.updateStatus(`Trying alternative model ${i + 1}/${modelUrls.length}...`);
                        console.log(`Trying fallback model: ${modelUrls[i]}`);
                        
                        this.model = await tf.loadGraphModel(modelUrls[i], {fromTFHub: true});
                        
                        console.log(`Alternative model ${i + 1} loaded successfully:`, this.model);
                        
                        // Warm up the model with a dummy prediction for better performance
                        await this.warmUpModel();
                        
                        this.updateStatus('🚀 Ready! Position yourself and start your push-ups!');
                        this.startDetection();
                        return; // Success, exit the function
                        
                    } catch (fallbackError) {
                        console.warn(`Fallback model ${i + 1} failed:`, fallbackError);
                        // Continue to next model
                    }
                }
                
                // All models failed
                console.error('All model loading attempts failed');
                this.updateStatus('Failed to load any MoveNet model. Please check your internet connection and refresh the page.');
            }
            
            startDetection() {
                this.isRunning = true;
                document.getElementById('startBtn').textContent = 'Stop Detection';
                document.getElementById('startBtn').onclick = () => this.stopDetection();
                document.getElementById('switchCameraBtn').style.display = 'inline-block';
                document.getElementById('debugBtn').style.display = 'inline-block';
                this.detectPoses();
            }
            
            stopDetection() {
                this.isRunning = false;
                document.getElementById('startBtn').textContent = 'Start Detection';
                document.getElementById('startBtn').onclick = () => this.startDetection();
                document.getElementById('switchCameraBtn').style.display = 'none';
                document.getElementById('debugBtn').style.display = 'none';
                this.updateStatus('Detection stopped.');
            }
            
            async detectPoses() {
                if (!this.isRunning || !this.model) return;
                
                const startTime = performance.now();
                
                try {
                    // Convert video frame to tensor
                    const imageTensor = tf.browser.fromPixels(this.video);
                    
                    // Resize to 192x192 (MoveNet Lightning input size)
                    const resized = tf.image.resizeBilinear(imageTensor, [192, 192]);
                    
                    // Expand dimensions to match expected input shape [1, 192, 192, 3]
                    const inputTensor = tf.expandDims(resized, 0);
                    
                    // Convert to int32 with proper value range [0,255] as expected by MoveNet
                    const input = tf.cast(inputTensor, 'int32');
                    
                    // Run inference
                    const prediction = await this.model.predict(input);
                    
                    // Get keypoints from the prediction
                    // MoveNet output shape is [1, 1, 17, 3] where each keypoint has [y, x, confidence]
                    const keypoints = await prediction.data();
                    
                    // Process keypoints into a more usable format
                    const processedKeypoints = this.processKeypoints(keypoints);
                    
                    // Filter for high-confidence keypoints
                    const highConfidenceKeypoints = processedKeypoints.filter(kp => kp.score > this.minConfidence);
                    
                    if (highConfidenceKeypoints.length > 5) { // Need at least 5 keypoints for meaningful detection
                        const pose = { keypoints: processedKeypoints };
                        console.log('Pose detected with', highConfidenceKeypoints.length, 'high-confidence keypoints');
                        this.drawPose(pose);
                        this.analyzePushUp(pose);
                    } else {
                        this.updateStatus('No person detected - please position yourself in view');
                        console.log('Insufficient high-confidence keypoints:', highConfidenceKeypoints.length);
                    }
                    
                    // Clean up tensors to prevent memory leaks
                    imageTensor.dispose();
                    resized.dispose();
                    inputTensor.dispose();
                    input.dispose();
                    prediction.dispose();
                    
                    // Track performance
                    const endTime = performance.now();
                    this.trackPerformance(endTime - startTime);
                    
                } catch (error) {
                    console.error('Error detecting pose:', error);
                    this.updateStatus('Error detecting pose: ' + error.message);
                }
                
                // Adaptive frame rate for mobile battery optimization
                let frameInterval = 33; // Default 30 FPS
                
                // Adjust frame rate based on performance and battery
                if (this.inferenceTime > 50) {
                    frameInterval = 66; // 15 FPS for slower devices
                } else if (this.inferenceTime > 30) {
                    frameInterval = 50; // 20 FPS for medium devices
                }
                
                // Further reduce frame rate if device seems to be struggling
                if (navigator.deviceMemory && navigator.deviceMemory < 4) {
                    frameInterval = Math.max(frameInterval, 50); // Max 20 FPS for low-memory devices
                }
                
                // Use requestAnimationFrame for smooth performance
                setTimeout(() => {
                    requestAnimationFrame(() => this.detectPoses());
                }, frameInterval);
            }
            
            async warmUpModel() {
                try {
                    console.log('Warming up MoveNet model...');
                    
                    // Create a dummy input tensor matching MoveNet input format
                    // Shape: [1, 192, 192, 3] with int32 values in range [0, 255]
                    const dummyInput = tf.zeros([1, 192, 192, 3], 'int32');
                    
                    // Run a prediction to warm up the model
                    const warmupPrediction = await this.model.predict(dummyInput);
                    
                    // Dispose of tensors to free memory
                    dummyInput.dispose();
                    warmupPrediction.dispose();
                    
                    console.log('Model warmed up successfully');
                    
                } catch (error) {
                    console.error('Error warming up model:', error);
                    // Don't throw error, just log it - the model might still work
                }
            }
            
            processKeypoints(keypoints) {
                // MoveNet output format: [y, x, confidence] for each of 17 keypoints
                // Convert to the format expected by the visualization
                const processedKeypoints = [];
                const keypointNames = [
                    'nose', 'left_eye', 'right_eye', 'left_ear', 'right_ear',
                    'left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow',
                    'left_wrist', 'right_wrist', 'left_hip', 'right_hip',
                    'left_knee', 'right_knee', 'left_ankle', 'right_ankle'
                ];
                
                for (let i = 0; i < 17; i++) {
                    const idx = i * 3;
                    const y = keypoints[idx];
                    const x = keypoints[idx + 1];
                    const score = keypoints[idx + 2];
                    
                    // Convert normalized coordinates to pixel coordinates
                    const pixelX = x * this.video.videoWidth;
                    const pixelY = y * this.video.videoHeight;
                    
                    processedKeypoints.push({
                        name: keypointNames[i],
                        x: pixelX,
                        y: pixelY,
                        score: score,
                        position: { x: pixelX, y: pixelY }
                    });
                }
                
                return processedKeypoints;
            }
            
            trackPerformance(inferenceTime) {
                // Track inference time for performance monitoring
                this.inferenceTime = inferenceTime;
                
                // Log performance occasionally
                if (this.pushUpCount % 10 === 0) {
                    console.log(`Performance: ${inferenceTime.toFixed(2)}ms per frame`);
                }
            }
            
            drawPose(pose) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const minConfidence = this.minConfidence;
                
                // Calculate scaling factors for the current canvas setup
                const videoRect = this.video.getBoundingClientRect();
                const scaleX = videoRect.width / this.video.videoWidth;
                const scaleY = videoRect.height / this.video.videoHeight;
                
                // Get key body parts for visual tracking (MoveNet format)
                const nose = pose.keypoints.find(kp => kp.name === 'nose');
                const leftShoulder = pose.keypoints.find(kp => kp.name === 'left_shoulder');
                const rightShoulder = pose.keypoints.find(kp => kp.name === 'right_shoulder');
                const leftElbow = pose.keypoints.find(kp => kp.name === 'left_elbow');
                const rightElbow = pose.keypoints.find(kp => kp.name === 'right_elbow');
                const leftWrist = pose.keypoints.find(kp => kp.name === 'left_wrist');
                const rightWrist = pose.keypoints.find(kp => kp.name === 'right_wrist');
                const leftHip = pose.keypoints.find(kp => kp.name === 'left_hip');
                const rightHip = pose.keypoints.find(kp => kp.name === 'right_hip');
                
                // Draw body tracking box (simplified for mobile performance)
                if (leftShoulder && rightShoulder && leftShoulder.score >= minConfidence && rightShoulder.score >= minConfidence) {
                    const centerX = ((leftShoulder.x + rightShoulder.x) / 2) * scaleX;
                    const centerY = ((leftShoulder.y + rightShoulder.y) / 2) * scaleY;
                    const bodyWidth = Math.abs(rightShoulder.x - leftShoulder.x) * scaleX * 1.8;
                    const bodyHeight = bodyWidth * 1.5; // Estimated body height
                    
                    // Draw body tracking rectangle
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(centerX - bodyWidth/2, centerY - bodyHeight/2, bodyWidth, bodyHeight);
                    
                    // Draw center point
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                // Draw key points with different colors (optimized set for mobile)
                const keyPointColors = {
                    'nose': '#ff0000',
                    'left_shoulder': '#00ff00',
                    'right_shoulder': '#00ff00',
                    'left_elbow': '#ffff00',
                    'right_elbow': '#ffff00',
                    'left_wrist': '#ff00ff',
                    'right_wrist': '#ff00ff'
                };
                
                // Only draw important keypoints for performance
                pose.keypoints.forEach(keypoint => {
                    if (keypoint.score >= minConfidence && keyPointColors[keypoint.name]) {
                        this.ctx.beginPath();
                        this.ctx.arc(
                            keypoint.x * scaleX, 
                            keypoint.y * scaleY, 
                            4, 0, 2 * Math.PI
                        );
                        this.ctx.fillStyle = keyPointColors[keypoint.name];
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                    }
                });
                
                // Draw essential skeleton connections only (for mobile performance)
                const connections = [
                    ['left_shoulder', 'right_shoulder'],
                    ['left_shoulder', 'left_elbow'],
                    ['right_shoulder', 'right_elbow'],
                    ['left_elbow', 'left_wrist'],
                    ['right_elbow', 'right_wrist']
                ];
                
                connections.forEach(([part1, part2]) => {
                    const point1 = pose.keypoints.find(kp => kp.name === part1);
                    const point2 = pose.keypoints.find(kp => kp.name === part2);
                    
                    if (point1 && point2 && point1.score >= minConfidence && point2.score >= minConfidence) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(point1.x * scaleX, point1.y * scaleY);
                        this.ctx.lineTo(point2.x * scaleX, point2.y * scaleY);
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                });
                
                // Draw push-up status indicator (mobile-optimized)
                const statusY = 25;
                this.ctx.font = 'bold 16px -apple-system, sans-serif';
                this.ctx.fillStyle = '#ffffff';
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 2;
                
                const statusText = this.position === 'up' ? '⬆️ UP' : 
                                 this.position === 'down' ? '⬇️ DOWN' : 
                                 this.position === 'middle' ? '🔄 MID' :
                                 '➡️ READY';
                this.ctx.strokeText(statusText, 10, statusY);
                this.ctx.fillText(statusText, 10, statusY);
            }
            
            analyzePushUp(pose) {
                const keypoints = pose.keypoints;
                
                // Get key body parts for push-up detection
                const leftShoulder = keypoints.find(kp => kp.name === 'left_shoulder');
                const rightShoulder = keypoints.find(kp => kp.name === 'right_shoulder');
                const leftElbow = keypoints.find(kp => kp.name === 'left_elbow');
                const rightElbow = keypoints.find(kp => kp.name === 'right_elbow');
                const nose = keypoints.find(kp => kp.name === 'nose');
                
                // Check if we have enough keypoints for analysis
                if (!leftShoulder || !rightShoulder || !nose) {
                    this.updatePositionDisplay('--', 'Ready to start');
                    return;
                }
                
                // Calculate average confidence
                const validKeypoints = keypoints.filter(kp => kp.score > this.minConfidence);
                const avgConfidence = validKeypoints.length > 0 ? 
                    validKeypoints.reduce((sum, kp) => sum + kp.score, 0) / validKeypoints.length : 0;
                
                this.updateConfidenceDisplay(avgConfidence);
                
                // Check if key points meet minimum confidence
                if (leftShoulder.score < this.minConfidence || rightShoulder.score < this.minConfidence || 
                    nose.score < this.minConfidence) {
                    this.updatePositionDisplay('--', 'Position yourself better');
                    return;
                }
                
                // Calculate shoulder and nose positions
                const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
                const noseY = nose.y;
                
                // Determine position based on relative positions
                let currentPos = 'neutral';
                
                // Push-up detection: when shoulders are significantly below nose (down position)
                // and when they're close to nose level (up position)
                const shoulderNoseDiff = shoulderY - noseY;
                
                if (shoulderNoseDiff > 80) { // Shoulders well below nose
                    currentPos = 'down';
                } else if (shoulderNoseDiff > 30) { // Shoulders slightly below nose
                    currentPos = 'middle';
                } else { // Shoulders at or above nose level
                    currentPos = 'up';
                }
                
                // Count push-ups based on position transitions
                if (this.position !== currentPos) {
                    console.log(`Position changed: ${this.position} → ${currentPos}`);
                    
                    // Count a push-up when going from down to up
                    if (this.position === 'down' && currentPos === 'up') {
                        this.pushUpCount++;
                        this.updateDisplay();
                        this.updateStatus(`🎉 Push-up #${this.pushUpCount} completed!`);
                        console.log(`Push-up counted! Total: ${this.pushUpCount}`);
                    }
                    
                    this.lastPosition = this.position;
                    this.position = currentPos;
                }
                
                // Update position display
                this.updatePositionDisplay(currentPos, this.getPositionText(currentPos));
            }
            
            updateConfidenceDisplay(confidence) {
                if (this.confidenceDisplay) {
                    this.confidenceDisplay.textContent = `${(confidence * 100).toFixed(0)}%`;
                }
            }
            
            updatePositionDisplay(position, text) {
                if (this.positionDisplay) {
                    this.positionDisplay.textContent = position.toUpperCase();
                }
                if (this.positionIndicator) {
                    this.positionIndicator.textContent = text;
                    this.positionIndicator.className = `position-indicator position-${position}`;
                }
            }
            
            getPositionText(position) {
                switch (position) {
                    case 'up':
                        return '⬆️ Up Position - Good!';
                    case 'down':
                        return '⬇️ Down Position - Push up!';
                    case 'middle':
                        return '🔄 Middle Position';
                    case 'neutral':
                        return '🎯 Neutral Position';
                    default:
                        return 'Ready to start';
                }
            }
            
            resetCounter() {
                this.pushUpCount = 0;
                this.position = 'unknown';
                this.lastPosition = 'unknown';
                this.updateDisplay();
                this.updatePositionDisplay('--', 'Ready to start');
                this.updateConfidenceDisplay(0);
                this.updateStatus('Counter reset! Ready to start counting push-ups.');
            }
            
            updateDisplay() {
                if (this.countDisplay) {
                    this.countDisplay.textContent = this.pushUpCount;
                }
            }
            
            updateStatus(message) {
                if (this.statusDisplay) {
                    this.statusDisplay.textContent = message;
                }
                console.log('Status:', message);
            }
            
            showDebugInfo() {
                if (!this.isRunning) return;
                
                const debugInfo = `
                    === DEBUG INFO ===
                    Model: ${this.model ? 'MoveNet Loaded' : 'No Model'}
                    Inference Time: ${this.inferenceTime ? this.inferenceTime.toFixed(2) + 'ms' : 'N/A'}
                    Frame Rate: ${this.inferenceTime ? (1000 / this.inferenceTime).toFixed(1) + ' FPS' : 'N/A'}
                    Min Confidence: ${this.minConfidence}
                    Video Dimensions: ${this.video.videoWidth}x${this.video.videoHeight}
                    Canvas Dimensions: ${this.canvas.width}x${this.canvas.height}
                    Current Position: ${this.position}
                    Last Position: ${this.lastPosition}
                    Push-up Count: ${this.pushUpCount}
                    Camera: ${this.facingMode === 'user' ? 'Front' : 'Rear'}
                    === END DEBUG ===
                `;
                
                console.log(debugInfo);
                alert(debugInfo);
            }
        }
        
        // Initialize the app
        const pushUpCounter = new PushUpCounter();
        
        // Generate PWA manifest dynamically
        const manifest = {
            "name": "AI Push-Up Counter",
            "short_name": "Push-Up Counter",
            "description": "AI-powered push-up counter using Google's MoveNet model",
            "start_url": "./",
            "display": "standalone",
            "background_color": "#667eea",
            "theme_color": "#667eea",
            "orientation": "portrait-primary",
            "icons": [
                {
                    "src": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'%3E%3Crect width='192' height='192' fill='%23667eea'/%3E%3Ctext x='96' y='130' font-size='120' text-anchor='middle'%3E🏋️‍♂️%3C/text%3E%3C/svg%3E",
                    "sizes": "192x192",
                    "type": "image/svg+xml"
                },
                {
                    "src": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect width='512' height='512' fill='%23667eea'/%3E%3Ctext x='256' y='350' font-size='320' text-anchor='middle'%3E🏋️‍♂️%3C/text%3E%3C/svg%3E",
                    "sizes": "512x512",
                    "type": "image/svg+xml"
                }
            ]
        };
        
        // Create and inject manifest
        const manifestBlob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(manifestBlob);
        document.getElementById('manifest-placeholder').href = manifestURL;
        
        // Mobile-specific functionality
        function toggleInstructions() {
            const content = document.getElementById('instructionsContent');
            const toggle = document.getElementById('instructionsToggle');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.textContent = '▼';
                toggle.style.transform = 'rotate(0deg)';
            } else {
                content.classList.add('expanded');
                toggle.textContent = '▲';
                toggle.style.transform = 'rotate(180deg)';
            }
        }
        
        // Prevent zoom on double-tap for better mobile experience
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // Handle orientation changes
        window.addEventListener('orientationchange', function() {
            setTimeout(() => {
                if (pushUpCounter.video && pushUpCounter.video.srcObject) {
                    pushUpCounter.setupCanvas();
                }
            }, 500);
        });
        
        // Optimize for mobile performance
        if ('serviceWorker' in navigator) {
            // Register service worker for PWA functionality (optional)
            // navigator.serviceWorker.register('/sw.js');
        }
        
        // Prevent mobile browser pulldown refresh
        document.body.addEventListener('touchstart', e => {
            if (e.touches.length === 1 && window.scrollY === 0) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.body.addEventListener('touchmove', e => {
            if (e.touches.length === 1 && window.scrollY === 0) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html> 