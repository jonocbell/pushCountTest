<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Push-Up Counter</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@latest"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 5px;
        }
        
        h1 {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .video-container {
            position: relative;
            display: block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            width: 100%;
            max-width: 480px;
            margin-left: auto;
            margin-right: auto;
        }
        
        #video {
            width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
            transform: scaleX(-1); /* Mirror front camera by default */
        }
        
        #video.rear-camera {
            transform: scaleX(1); /* Don't mirror rear camera */
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
            flex: 1;
            min-width: 100px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .stat-number {
            font-size: clamp(1.5rem, 8vw, 2.5rem);
            font-weight: bold;
            display: block;
            color: #ffeb3b;
        }
        
        .stat-label {
            font-size: clamp(0.8rem, 3vw, 1rem);
            opacity: 0.9;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 16px 32px;
            font-size: clamp(1rem, 4vw, 1.2rem);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            max-width: 300px;
            min-height: 50px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        button:hover, button:focus {
            background: #45a049;
            transform: translateY(-2px);
            outline: none;
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .instructions {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: left;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .instructions h3 {
            font-size: clamp(1rem, 4vw, 1.3rem);
            margin-bottom: 10px;
        }
        
        .instructions ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .instructions li {
            font-size: clamp(0.85rem, 3.5vw, 1rem);
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        .status {
            font-size: clamp(1rem, 4vw, 1.2rem);
            margin: 15px 0;
            padding: 12px;
            border-radius: 12px;
            background: rgba(0,0,0,0.2);
            line-height: 1.3;
        }
        
        .position-indicator {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            margin: 15px 0;
            padding: 12px;
            border-radius: 12px;
            font-weight: bold;
            line-height: 1.2;
        }
        
        .position-up {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }
        
        .position-down {
            background: rgba(255, 152, 0, 0.3);
            color: #FF9800;
        }
        
        .position-neutral {
            background: rgba(158, 158, 158, 0.3);
            color: #9E9E9E;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .container {
                padding: 0;
            }
            
            .stats {
                margin: 15px 0;
            }
            
            .stat-card {
                padding: 12px;
            }
            
            .instructions {
                padding: 12px;
            }
            
            .instructions li {
                margin-bottom: 6px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 3px;
            }
            
            h1 {
                margin-bottom: 15px;
            }
            
            .video-container {
                margin-bottom: 15px;
            }
            
            .controls {
                margin: 15px 0;
            }
            
            button {
                padding: 14px 28px;
                min-height: 48px;
            }
            
            .stats {
                margin: 10px 0;
            }
            
            .stat-card {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèãÔ∏è‚Äç‚ôÇÔ∏è Push-Up Counter</h1>
        
        <div class="video-container">
            <video id="video" autoplay muted playsinline webkit-playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="controls">
            <button id="startBtn">Start Camera</button>
            <button id="switchCameraBtn" style="display: none;">Switch Camera üîÑ</button>
            <button id="resetBtn">Reset Counter</button>
            <button id="debugBtn" style="display: none;">Debug Info üîç</button>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <span class="stat-number" id="pushupCount">0</span>
                <span class="stat-label">Push-ups</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="currentPosition">--</span>
                <span class="stat-label">Position</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="confidence">--</span>
                <span class="stat-label">Confidence</span>
            </div>
        </div>
        
        <div class="position-indicator" id="positionIndicator">
            Ready to start
        </div>
        
        <div class="status" id="status">
            Click "Start Camera" to begin with Google's MoveNet AI
        </div>
        
        <div class="instructions">
            <h3>üìã Instructions:</h3>
            <ul>
                <li><strong>Advanced AI:</strong> Now powered by Google's MoveNet model - ultra-fast and accurate!</li>
                <li><strong>Auto-detection:</strong> No calibration needed - just start exercising!</li>
                <li><strong>Position yourself:</strong> Make sure your upper body and arms are visible in the camera</li>
                <li><strong>Visual tracking:</strong> Colored keypoints and skeleton show real-time body tracking</li>
                <li><strong>Smart counting:</strong> Automatically counts complete push-ups with proper form</li>
                <li><strong>Camera options:</strong> Starts with front camera to see your count, switch to rear if preferred</li>
                <li><strong>Real-time:</strong> Optimized for mobile with 30+ FPS performance</li>
            </ul>
        </div>
    </div>

    <script>
        class PushUpCounter {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.countDisplay = document.getElementById('pushupCount');
                this.statusDisplay = document.getElementById('status');
                this.debugDisplay = document.getElementById('debugBtn');
                this.positionDisplay = document.getElementById('currentPosition');
                this.positionIndicator = document.getElementById('positionIndicator');
                this.confidenceDisplay = document.getElementById('confidence');
                
                this.model = null;
                this.isRunning = false;
                this.pushUpCount = 0;
                this.position = 'unknown';
                this.lastPosition = 'unknown';
                this.minConfidence = 0.3;
                this.performanceMode = false;
                this.facingMode = 'user'; // Start with front camera
                this.inferenceTime = 0; // Track inference performance
                this.currentStream = null;
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.updateDisplay();
            }
            
            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startCamera();
                });
                
                document.getElementById('switchCameraBtn').addEventListener('click', () => {
                    this.switchCamera();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetCounter();
                });
                
                document.getElementById('debugBtn').addEventListener('click', () => {
                    this.showDebugInfo();
                });
            }
            
            async startCamera() {
                try {
                    this.updateStatus('Loading camera...');
                    
                    // Check if running on HTTPS or localhost
                    const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                    
                    if (!isSecure) {
                        this.updateStatus('‚ö†Ô∏è Camera requires HTTPS. Please use: 1) GitHub Pages 2) CodePen 3) Netlify Drop');
                        return;
                    }
                    
                    // Check for getUserMedia support
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        // Fallback for older browsers
                        navigator.getUserMedia = navigator.getUserMedia || 
                                               navigator.webkitGetUserMedia || 
                                               navigator.mozGetUserMedia || 
                                               navigator.msGetUserMedia;
                        
                        if (!navigator.getUserMedia) {
                            this.updateStatus('‚ùå Camera not supported by your browser. Try Chrome or Safari.');
                            return;
                        }
                        
                        // Use legacy getUserMedia
                        const constraints = {
                            video: { 
                                width: { ideal: 640, max: 1280 },
                                height: { ideal: 480, max: 720 },
                                facingMode: this.facingMode
                            }
                        };
                        
                        navigator.getUserMedia(constraints, (stream) => {
                            this.currentStream = stream;
                            this.video.srcObject = stream;
                            this.video.addEventListener('loadeddata', () => {
                                this.setupCanvas();
                                this.loadModel();
                                this.updateVideoMirror();
                            });
                            document.getElementById('startBtn').disabled = true;
                            document.getElementById('switchCameraBtn').style.display = 'block';
                            document.getElementById('debugBtn').style.display = 'block';
                        }, (error) => {
                            console.error('Legacy getUserMedia error:', error);
                            this.updateStatus('Error: ' + error.message);
                        });
                        return;
                    }
                    
                    // Use current facing mode (starts with front camera so user can see the count)
                    let constraints = {
                        video: { 
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            facingMode: this.facingMode
                        }
                    };
                    
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia(constraints);
                        this.currentStream = stream;
                        this.video.srcObject = stream;
                    } catch (error) {
                        // Fallback to opposite camera
                        console.log(`${this.facingMode} camera not available, trying opposite camera`);
                        constraints.video.facingMode = this.facingMode === 'user' ? 'environment' : 'user';
                        const stream = await navigator.mediaDevices.getUserMedia(constraints);
                        this.currentStream = stream;
                        this.facingMode = constraints.video.facingMode;
                        this.video.srcObject = stream;
                    }
                    
                    this.video.addEventListener('loadeddata', () => {
                        this.setupCanvas();
                        this.loadModel();
                        this.updateVideoMirror();
                    });
                    
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('switchCameraBtn').style.display = 'block';
                    document.getElementById('debugBtn').style.display = 'block';
                    
                } catch (error) {
                    console.error('Error accessing camera:', error);
                    let errorMessage = 'Error accessing camera: ';
                    
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Camera permission denied. Please allow camera access.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += 'No camera found on this device.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'Camera not supported by your browser.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus(errorMessage);
                }
            }
            
            async switchCamera() {
                try {
                    // Stop current stream
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                    }
                    
                    // Switch facing mode
                    this.facingMode = this.facingMode === 'user' ? 'environment' : 'user';
                    
                    // Start new stream
                    this.updateStatus('Switching camera...');
                    
                    const constraints = {
                        video: { 
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            facingMode: this.facingMode
                        }
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.currentStream = stream;
                    this.video.srcObject = stream;
                    
                    // Reset detection when switching cameras
                    this.position = 'unknown';
                    this.lastPosition = 'unknown';
                    
                    this.video.addEventListener('loadeddata', () => {
                        this.setupCanvas();
                        this.updateVideoMirror();
                        this.updateStatus('Camera switched! Ready to detect push-ups.');
                    });
                    
                } catch (error) {
                    console.error('Error switching camera:', error);
                    this.updateStatus('Error switching camera: ' + error.message);
                }
            }
            
            setupCanvas() {
                // Set canvas size to match video dimensions
                const rect = this.video.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }
            
            updateVideoMirror() {
                // Mirror front camera, don't mirror rear camera
                if (this.facingMode === 'user') {
                    this.video.classList.remove('rear-camera');
                } else {
                    this.video.classList.add('rear-camera');
                }
            }
            
            async loadModel() {
                try {
                    this.updateStatus('Loading MoveNet model...');
                    console.log('Starting MoveNet model load...');
                    
                    // Load the official TensorFlow Hub MoveNet Lightning model using correct method
                    const modelUrl = 'https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4';
                    
                    console.log('Loading model from:', modelUrl);
                    // Use tf.loadGraphModel for TensorFlow Hub models
                    this.model = await tf.loadGraphModel(modelUrl, {fromTFHub: true});
                    
                    console.log('MoveNet model loaded successfully:', this.model);
                    
                    // Warm up the model with a dummy prediction for better performance
                    await this.warmUpModel();
                    
                    this.updateStatus('üöÄ Ready! Position yourself and start your push-ups!');
                    this.startDetection();
                    
                } catch (error) {
                    console.error('Error loading MoveNet model:', error);
                    this.updateStatus('Error loading model: ' + error.message + ' - Trying alternatives...');
                    
                    // Try alternative model URLs
                    this.tryAlternativeModel();
                }
            }
            
            async tryAlternativeModel() {
                // Multiple fallback models in order of preference
                const modelUrls = [
                    'https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4',
                    'https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/3',
                    'https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/3'
                ];
                
                for (let i = 0; i < modelUrls.length; i++) {
                    try {
                        this.updateStatus(`Trying alternative model ${i + 1}/${modelUrls.length}...`);
                        console.log(`Trying fallback model: ${modelUrls[i]}`);
                        
                        this.model = await tf.loadGraphModel(modelUrls[i], {fromTFHub: true});
                        
                        console.log(`Alternative model ${i + 1} loaded successfully:`, this.model);
                        
                        // Warm up the model with a dummy prediction for better performance
                        await this.warmUpModel();
                        
                        this.updateStatus('üöÄ Ready! Position yourself and start your push-ups!');
                        this.startDetection();
                        return; // Success, exit the function
                        
                    } catch (fallbackError) {
                        console.warn(`Fallback model ${i + 1} failed:`, fallbackError);
                        // Continue to next model
                    }
                }
                
                // All models failed
                console.error('All model loading attempts failed');
                this.updateStatus('Failed to load any MoveNet model. Please check your internet connection and refresh the page.');
            }
            
            startDetection() {
                this.isRunning = true;
                document.getElementById('startBtn').textContent = 'Stop Detection';
                document.getElementById('startBtn').onclick = () => this.stopDetection();
                document.getElementById('switchCameraBtn').style.display = 'inline-block';
                document.getElementById('debugBtn').style.display = 'inline-block';
                this.detectPoses();
            }
            
            stopDetection() {
                this.isRunning = false;
                document.getElementById('startBtn').textContent = 'Start Detection';
                document.getElementById('startBtn').onclick = () => this.startDetection();
                document.getElementById('switchCameraBtn').style.display = 'none';
                document.getElementById('debugBtn').style.display = 'none';
                this.updateStatus('Detection stopped.');
            }
            
            async detectPoses() {
                if (!this.isRunning || !this.model) return;
                
                const startTime = performance.now();
                
                try {
                    // Convert video frame to tensor
                    const imageTensor = tf.browser.fromPixels(this.video);
                    
                    // Resize to 192x192 (MoveNet Lightning input size)
                    const resized = tf.image.resizeBilinear(imageTensor, [192, 192]);
                    
                    // Expand dimensions to match expected input shape [1, 192, 192, 3]
                    const inputTensor = tf.expandDims(resized, 0);
                    
                    // Convert to int32 with proper value range [0,255] as expected by MoveNet
                    const input = tf.cast(inputTensor, 'int32');
                    
                    // Run inference
                    const prediction = await this.model.predict(input);
                    
                    // Get keypoints from the prediction
                    // MoveNet output shape is [1, 1, 17, 3] where each keypoint has [y, x, confidence]
                    const keypoints = await prediction.data();
                    
                    // Process keypoints into a more usable format
                    const processedKeypoints = this.processKeypoints(keypoints);
                    
                    // Filter for high-confidence keypoints
                    const highConfidenceKeypoints = processedKeypoints.filter(kp => kp.score > this.minConfidence);
                    
                    if (highConfidenceKeypoints.length > 5) { // Need at least 5 keypoints for meaningful detection
                        const pose = { keypoints: processedKeypoints };
                        console.log('Pose detected with', highConfidenceKeypoints.length, 'high-confidence keypoints');
                        this.drawPose(pose);
                        this.analyzePushUp(pose);
                    } else {
                        this.updateStatus('No person detected - please position yourself in view');
                        console.log('Insufficient high-confidence keypoints:', highConfidenceKeypoints.length);
                    }
                    
                    // Clean up tensors to prevent memory leaks
                    imageTensor.dispose();
                    resized.dispose();
                    inputTensor.dispose();
                    input.dispose();
                    prediction.dispose();
                    
                    // Track performance
                    const endTime = performance.now();
                    this.trackPerformance(endTime - startTime);
                    
                } catch (error) {
                    console.error('Error detecting pose:', error);
                    this.updateStatus('Error detecting pose: ' + error.message);
                }
                
                // Improved frame rate for better performance (30 FPS instead of 10 FPS)
                setTimeout(() => {
                    requestAnimationFrame(() => this.detectPoses());
                }, 33); // ~30 FPS for smooth real-time detection
            }
            
            async warmUpModel() {
                try {
                    console.log('Warming up MoveNet model...');
                    
                    // Create a dummy input tensor matching MoveNet input format
                    // Shape: [1, 192, 192, 3] with int32 values in range [0, 255]
                    const dummyInput = tf.zeros([1, 192, 192, 3], 'int32');
                    
                    // Run a prediction to warm up the model
                    const warmupPrediction = await this.model.predict(dummyInput);
                    
                    // Dispose of tensors to free memory
                    dummyInput.dispose();
                    warmupPrediction.dispose();
                    
                    console.log('Model warmed up successfully');
                    
                } catch (error) {
                    console.error('Error warming up model:', error);
                    // Don't throw error, just log it - the model might still work
                }
            }
            
            processKeypoints(keypoints) {
                // MoveNet output format: [y, x, confidence] for each of 17 keypoints
                // Convert to the format expected by the visualization
                const processedKeypoints = [];
                const keypointNames = [
                    'nose', 'left_eye', 'right_eye', 'left_ear', 'right_ear',
                    'left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow',
                    'left_wrist', 'right_wrist', 'left_hip', 'right_hip',
                    'left_knee', 'right_knee', 'left_ankle', 'right_ankle'
                ];
                
                for (let i = 0; i < 17; i++) {
                    const idx = i * 3;
                    const y = keypoints[idx];
                    const x = keypoints[idx + 1];
                    const score = keypoints[idx + 2];
                    
                    // Convert normalized coordinates to pixel coordinates
                    const pixelX = x * this.video.videoWidth;
                    const pixelY = y * this.video.videoHeight;
                    
                    processedKeypoints.push({
                        name: keypointNames[i],
                        x: pixelX,
                        y: pixelY,
                        score: score,
                        position: { x: pixelX, y: pixelY }
                    });
                }
                
                return processedKeypoints;
            }
            
            trackPerformance(inferenceTime) {
                // Track inference time for performance monitoring
                this.inferenceTime = inferenceTime;
                
                // Log performance occasionally
                if (this.pushUpCount % 10 === 0) {
                    console.log(`Performance: ${inferenceTime.toFixed(2)}ms per frame`);
                }
            }
            
            drawPose(pose) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const minConfidence = this.minConfidence;
                
                // Calculate scaling factors for mobile
                const scaleX = this.canvas.width / this.video.videoWidth;
                const scaleY = this.canvas.height / this.video.videoHeight;
                
                // Get key body parts for visual tracking (MoveNet format)
                const nose = pose.keypoints.find(kp => kp.name === 'nose');
                const leftShoulder = pose.keypoints.find(kp => kp.name === 'left_shoulder');
                const rightShoulder = pose.keypoints.find(kp => kp.name === 'right_shoulder');
                const leftElbow = pose.keypoints.find(kp => kp.name === 'left_elbow');
                const rightElbow = pose.keypoints.find(kp => kp.name === 'right_elbow');
                const leftWrist = pose.keypoints.find(kp => kp.name === 'left_wrist');
                const rightWrist = pose.keypoints.find(kp => kp.name === 'right_wrist');
                const leftHip = pose.keypoints.find(kp => kp.name === 'left_hip');
                const rightHip = pose.keypoints.find(kp => kp.name === 'right_hip');
                
                // Draw body tracking box
                if (leftShoulder && rightShoulder && leftHip && rightHip && 
                    leftShoulder.score >= minConfidence && rightShoulder.score >= minConfidence &&
                    leftHip.score >= minConfidence && rightHip.score >= minConfidence) {
                    
                    const centerX = ((leftShoulder.x + rightShoulder.x) / 2) * scaleX;
                    const centerY = ((leftShoulder.y + rightShoulder.y) / 2) * scaleY;
                    const bodyWidth = Math.abs(rightShoulder.x - leftShoulder.x) * scaleX * 1.5;
                    const bodyHeight = Math.abs(((leftHip.y + rightHip.y) / 2) - ((leftShoulder.y + rightShoulder.y) / 2)) * scaleY * 1.2;
                    
                    // Draw body tracking rectangle
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(centerX - bodyWidth/2, centerY - bodyHeight/2, bodyWidth, bodyHeight);
                    
                    // Draw center point
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                // Draw key points with different colors for different body parts (MoveNet format)
                const keyPointColors = {
                    'nose': '#ff0000',
                    'left_shoulder': '#00ff00',
                    'right_shoulder': '#00ff00',
                    'left_elbow': '#ffff00',
                    'right_elbow': '#ffff00',
                    'left_wrist': '#ff00ff',
                    'right_wrist': '#ff00ff',
                    'left_hip': '#00ffff',
                    'right_hip': '#00ffff'
                };
                
                pose.keypoints.forEach(keypoint => {
                    if (keypoint.score >= minConfidence && keyPointColors[keypoint.name]) {
                        this.ctx.beginPath();
                        this.ctx.arc(
                            keypoint.x * scaleX, 
                            keypoint.y * scaleY, 
                            6, 0, 2 * Math.PI
                        );
                        this.ctx.fillStyle = keyPointColors[keypoint.name];
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                });
                
                // Draw skeleton connections (MoveNet format)
                const connections = [
                    ['left_shoulder', 'right_shoulder'],
                    ['left_shoulder', 'left_elbow'],
                    ['right_shoulder', 'right_elbow'],
                    ['left_elbow', 'left_wrist'],
                    ['right_elbow', 'right_wrist'],
                    ['left_shoulder', 'left_hip'],
                    ['right_shoulder', 'right_hip'],
                    ['left_hip', 'right_hip']
                ];
                
                connections.forEach(([part1, part2]) => {
                    const point1 = pose.keypoints.find(kp => kp.name === part1);
                    const point2 = pose.keypoints.find(kp => kp.name === part2);
                    
                    if (point1 && point2 && point1.score >= minConfidence && point2.score >= minConfidence) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(point1.x * scaleX, point1.y * scaleY);
                        this.ctx.lineTo(point2.x * scaleX, point2.y * scaleY);
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 3;
                        this.ctx.stroke();
                    }
                });
                
                // Draw push-up status indicator
                const statusY = 30;
                this.ctx.font = 'bold 20px Arial';
                this.ctx.fillStyle = '#ffffff';
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 3;
                
                const statusText = this.position === 'up' ? '‚¨ÜÔ∏è UP' : 
                                 this.position === 'down' ? '‚¨áÔ∏è DOWN' : 
                                 this.position === 'middle' ? 'üîÑ MIDDLE' :
                                 '‚û°Ô∏è READY';
                this.ctx.strokeText(statusText, 10, statusY);
                this.ctx.fillText(statusText, 10, statusY);
            }
            
            analyzePushUp(pose) {
                const keypoints = pose.keypoints;
                
                // Get key body parts for push-up detection
                const leftShoulder = keypoints.find(kp => kp.name === 'left_shoulder');
                const rightShoulder = keypoints.find(kp => kp.name === 'right_shoulder');
                const leftElbow = keypoints.find(kp => kp.name === 'left_elbow');
                const rightElbow = keypoints.find(kp => kp.name === 'right_elbow');
                const nose = keypoints.find(kp => kp.name === 'nose');
                
                // Check if we have enough keypoints for analysis
                if (!leftShoulder || !rightShoulder || !nose) {
                    this.updatePositionDisplay('--', 'Ready to start');
                    return;
                }
                
                // Calculate average confidence
                const validKeypoints = keypoints.filter(kp => kp.score > this.minConfidence);
                const avgConfidence = validKeypoints.length > 0 ? 
                    validKeypoints.reduce((sum, kp) => sum + kp.score, 0) / validKeypoints.length : 0;
                
                this.updateConfidenceDisplay(avgConfidence);
                
                // Check if key points meet minimum confidence
                if (leftShoulder.score < this.minConfidence || rightShoulder.score < this.minConfidence || 
                    nose.score < this.minConfidence) {
                    this.updatePositionDisplay('--', 'Position yourself better');
                    return;
                }
                
                // Calculate shoulder and nose positions
                const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
                const noseY = nose.y;
                
                // Determine position based on relative positions
                let currentPos = 'neutral';
                
                // Push-up detection: when shoulders are significantly below nose (down position)
                // and when they're close to nose level (up position)
                const shoulderNoseDiff = shoulderY - noseY;
                
                if (shoulderNoseDiff > 80) { // Shoulders well below nose
                    currentPos = 'down';
                } else if (shoulderNoseDiff > 30) { // Shoulders slightly below nose
                    currentPos = 'middle';
                } else { // Shoulders at or above nose level
                    currentPos = 'up';
                }
                
                // Count push-ups based on position transitions
                if (this.position !== currentPos) {
                    console.log(`Position changed: ${this.position} ‚Üí ${currentPos}`);
                    
                    // Count a push-up when going from down to up
                    if (this.position === 'down' && currentPos === 'up') {
                        this.pushUpCount++;
                        this.updateDisplay();
                        this.updateStatus(`üéâ Push-up #${this.pushUpCount} completed!`);
                        console.log(`Push-up counted! Total: ${this.pushUpCount}`);
                    }
                    
                    this.lastPosition = this.position;
                    this.position = currentPos;
                }
                
                // Update position display
                this.updatePositionDisplay(currentPos, this.getPositionText(currentPos));
            }
            
            updateConfidenceDisplay(confidence) {
                if (this.confidenceDisplay) {
                    this.confidenceDisplay.textContent = `${(confidence * 100).toFixed(0)}%`;
                }
            }
            
            updatePositionDisplay(position, text) {
                if (this.positionDisplay) {
                    this.positionDisplay.textContent = position.toUpperCase();
                }
                if (this.positionIndicator) {
                    this.positionIndicator.textContent = text;
                    this.positionIndicator.className = `position-indicator position-${position}`;
                }
            }
            
            getPositionText(position) {
                switch (position) {
                    case 'up':
                        return '‚¨ÜÔ∏è Up Position - Good!';
                    case 'down':
                        return '‚¨áÔ∏è Down Position - Push up!';
                    case 'middle':
                        return 'üîÑ Middle Position';
                    case 'neutral':
                        return 'üéØ Neutral Position';
                    default:
                        return 'Ready to start';
                }
            }
            
            resetCounter() {
                this.pushUpCount = 0;
                this.position = 'unknown';
                this.lastPosition = 'unknown';
                this.updateDisplay();
                this.updatePositionDisplay('--', 'Ready to start');
                this.updateConfidenceDisplay(0);
                this.updateStatus('Counter reset! Ready to start counting push-ups.');
            }
            
            updateDisplay() {
                if (this.countDisplay) {
                    this.countDisplay.textContent = this.pushUpCount;
                }
            }
            
            updateStatus(message) {
                if (this.statusDisplay) {
                    this.statusDisplay.textContent = message;
                }
                console.log('Status:', message);
            }
            
            showDebugInfo() {
                if (!this.isRunning) return;
                
                const debugInfo = `
                    === DEBUG INFO ===
                    Model: ${this.model ? 'MoveNet Loaded' : 'No Model'}
                    Inference Time: ${this.inferenceTime ? this.inferenceTime.toFixed(2) + 'ms' : 'N/A'}
                    Frame Rate: ${this.inferenceTime ? (1000 / this.inferenceTime).toFixed(1) + ' FPS' : 'N/A'}
                    Min Confidence: ${this.minConfidence}
                    Video Dimensions: ${this.video.videoWidth}x${this.video.videoHeight}
                    Canvas Dimensions: ${this.canvas.width}x${this.canvas.height}
                    Current Position: ${this.position}
                    Last Position: ${this.lastPosition}
                    Push-up Count: ${this.pushUpCount}
                    Camera: ${this.facingMode === 'user' ? 'Front' : 'Rear'}
                    === END DEBUG ===
                `;
                
                console.log(debugInfo);
                alert(debugInfo);
            }
        }
        
        // Initialize the push-up counter when the page loads
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize TensorFlow.js backend for optimal performance
            await tf.ready();
            console.log('TensorFlow.js backend:', tf.getBackend());
            
            const counter = new PushUpCounter();
            
            // Handle orientation changes on mobile
            window.addEventListener('resize', () => {
                if (counter.video.srcObject) {
                    setTimeout(() => {
                        counter.setupCanvas();
                    }, 100);
                }
            });
            
            // Prevent zoom on double tap
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (event) => {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        });
    </script>
</body>
</html> 